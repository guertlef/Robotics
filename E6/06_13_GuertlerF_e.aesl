<!DOCTYPE aesl-source>
<network>


<!--list of global events-->


<!--list of constants-->
<constant value="0" name="NO_COLOR"/>
<constant value="1" name="RED"/>
<constant value="2" name="GREEN"/>
<constant value="3" name="BLUE"/>
<constant value="800" name="P_THRESH"/>
<constant value="400" name="S_INIT"/>


<!--show keywords state-->
<keywords flag="true"/>


<!--node e-puck3-->
<node nodeId="4" name="e-puck3">##########################################################
#
#	Robotics Project [SA 12] | University of Fribourg
#		
# 	Author:			GÃ¼rtler Fabienne
# 	Created:     	31.03.2015
# 	Last modified: 	31.03.2015
#
#	Description: 	Explorer behaviour with visual feedback
#					of color recognition
#
##########################################################

var camRed = 0
var camBlue = 0
var camGreen = 0
var i


var color = NO_COLOR

var proxRight
var proxLeft
var ds   # delta speed
var r
var b
var g

r=0
b=0
g=0

onevent camera
	# calculation of mean colors taken from demo
	for i in 0:4 do
		camRed += cam.red[i+28]	
	end
	camRed /= 4

	for i in 0:4 do
		camBlue += cam.blue[i+28]	
	end
	camBlue /= 4
	
	for i in 0:4 do
		camGreen += cam.green[i+28]	
	end
	camGreen /= 4
			
	if 2*camBlue -r &lt;= camRed and camRed &lt;= 4*camBlue +r  and
	   2*camGreen -r &lt;= camRed and camRed &lt;= 3*camGreen +r then
		color = RED
		
	elseif camRed -g &lt;= camGreen and 7*camBlue -g &lt;= 6*camGreen and
		   4*camGreen &lt;= 9*camBlue +5*g then
			color = GREEN
		
	elseif 7*camRed -b &lt;= 6*camBlue and 4*camBlue &lt;= 9*camRed +b and
		   camGreen -b &lt;= camBlue then
			color = BLUE
		
	else
		color = NO_COLOR
	end
	
onevent ir_sensors
	# visual feedback
	if color == NO_COLOR then
		leds[4] = 0
		leds[2] = 0
		leds[6] = 0
	
	elseif color == RED then
		leds[4] = 1
		leds[2] = 0
		leds[6] = 0
	
	elseif color == BLUE then
		leds[4] = 0
		leds[2] = 1
		leds[6] = 1
		
	elseif color == GREEN then
		leds[4] = 1
		leds[2] = 1
		leds[6] = 1
	end
	
	# explorer behavior from series 3
	# proximity
	proxRight = (4*prox[0] + 2*prox[1] + prox[2])/7
	proxLeft = (4*prox[7] + 2*prox[6] + prox[5])/7

	# check which side is closer to obstacle
	if proxRight > proxLeft then # turn left

		# delta speed ds
		call math.muldiv(ds, S_INIT, proxRight, P_THRESH)

		# right and left speed
	   	speed.right = S_INIT + ds
	   	speed.left = S_INIT - ds

	else # turn right

		# delta speed ds
		call math.muldiv(ds, S_INIT, proxLeft, P_THRESH)

		# right and left speed
		speed.right = S_INIT - ds
		speed.left = S_INIT + ds

	end </node>


</network>
